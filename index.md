# Polo++: Документация языка программирования

## Содержание
1. [Введение](#введение)
2. [Основные концепции](#основные-концепции)
3. [Типы данных](#типы-данных)
4. [Переменные и выражения](#переменные-и-выражения)
5. [Функции](#функции)
6. [Управляющие конструкции](#управляющие-конструкции)
7. [Операторы](#операторы)
8. [Работа со списками](#работа-со-списками)
9. [Архитектура интерпретатора](#архитектура-интерпретатора)
10. [Примеры программ](#примеры-программ)

## Введение

Polo++ - функциональный язык программирования, основанный на лямбда-исчислении. Язык поддерживает рекурсию, замыкания, функции высшего порядка и динамическую типизацию.

Интерпретатор языка реализован на F# с использованием библиотеки FParsec для парсинга.

## Типы данных

Polo++ поддерживает следующие типы данных:

### Int (целые числа)
Представляют целочисленные значения.

```
let x = int 42
```

### Float (числа с плавающей точкой)
Представляют числа с плавающей точкой.

```
let pi = float 3.14159
```

### String (строки)
Представляют текстовые данные, заключенные в двойные кавычки.

```
let greeting = str "Hello, World!"
```

Строки поддерживают экранированные последовательности:
- `\"` - двойная кавычка
- `\\` - обратная косая черта
- `\n` - новая строка
- `\r` - возврат каретки
- `\t` - табуляция

### Boolean (логические значения)
Представляют логические значения true и false.

```
let isActive = bool true
let isDisabled = bool false
```

### List (списки)
Представляют упорядоченные коллекции элементов, которые могут содержать значения любого типа.

```
// Пустой список
let emptyList = []

// Список целых чисел
let numbers = [int 1, int 2, int 3, int 4, int 5]

// Список смешанных типов
let mixed = [int 1, float 2.5, str "hello"]
```

Для работы со списками доступны следующие встроенные функции:

- `cons` - добавляет элемент в начало списка
  ```
  exec cons (int 0, numbers)  // Результат: [0, 1, 2, 3, 4, 5]
  ```

- `head` - возвращает первый элемент списка
  ```
  exec head (numbers)  // Результат: 1
  ```

- `tail` - возвращает список без первого элемента
  ```
  exec tail (numbers)  // Результат: [2, 3, 4, 5]
  ```

- `isEmpty` - проверяет, пуст ли список
  ```
  exec isEmpty (emptyList)  // Результат: true
  exec isEmpty (numbers)    // Результат: false
  ```

- `last` - возвращает последний элемент списка
  ```
  exec last (numbers)  // Результат: 5
  ```

- `at` - возвращает элемент по индексу (нумерация с 0)
  ```
  exec at (numbers, int 1)  // Результат: 2
  ```

- `map` - применяет функцию к каждому элементу списка
  ```
  let double = lambda (x) { (x * int 2) }
  exec map (double, numbers)  // Результат: [2, 4, 6, 8, 10]
  ```

### Функции
Функции являются значениями первого класса и могут быть присвоены переменным, переданы как аргументы и возвращены как результаты.

```
let add = lambda (a, b) {
    (a + b)
}
```

## Динамическая типизация

Polo++ использует динамическую типизацию:

1. Типы переменных определяются во время выполнения
2. Переменные могут хранить значения разных типов в разное время
3. Операции проверяют совместимость типов во время выполнения

Язык поддерживает автоматическое приведение типов в некоторых случаях:
- `Int` → `Float` при арифметических операциях
- Любой тип → `String` при конкатенации со строкой

Примеры:
```
let result = (int 5 + float 3.14)  // Результат: Float 8.14
let message = (str "Value: " + int 42)  // Результат: String "Value: 42"
```

## Переменные и выражения

### Объявление переменных

Переменные объявляются с помощью ключевого слова `let`:

```
let name = выражение
```

Переменные в Polo++ неизменяемы - после присвоения значения его нельзя изменить. Однако можно создать новую переменную с тем же именем, которая скроет предыдущую:

```
let x = int 5
let x = int 10  // Создает новую переменную x, скрывающую предыдущую
```

### Выражения

Все конструкции в Polo++ являются выражениями, возвращающими значения. Выражения могут быть:

- Литералами: `int 5`, `float 3.14`, `str "hello"`, `bool true`
- Переменными: `x`, `name`, `result`
- Операциями: `(a + b)`, `(x * y)`, `(str1 + str2)`
- Вызовами функций: `exec add (x, y)`
- Условными выражениями: `if (condition) { expr1 } else { expr2 }`
- Определениями функций: `lambda (x) { (x * x) }`

## Функции

### Определение функций

Функции определяются с помощью ключевого слова `lambda`:

```
let functionName = lambda (param1, param2, ...) {
    тело_функции
}
```

Тело функции - выражение, значение которого будет возвращено при вызове функции.

### Вызов функций

Функции вызываются с помощью ключевого слова `exec`:

```
exec functionName (arg1, arg2, ...)
```

Аргументы функции заключаются в скобки и разделяются запятыми.

### Рекурсивные функции

Для определения рекурсивных функций используется ключевое слово `reclet`:

```
reclet functionName = lambda (params) {
    // Тело с рекурсивными вызовами
    
    exec functionName (...)
}
```

Пример рекурсивной функции для вычисления факториала:

```
reclet factorial = lambda (n) {
    if (n <= int 1) {
        int 1
    } else {
        (n * exec factorial ((n - int 1)))
    }
}
```

### Функции высшего порядка

Функции могут принимать другие функции в качестве аргументов и возвращать функции как результаты:

```
// Функция, принимающая другую функцию как аргумент
let applyTwice = lambda (f, x) {
    exec f (exec f (x))
}

// Функция, возвращающая другую функцию
let makeAdder = lambda (a) {
    lambda (b) {
        (a + b)
    }
}
```

### Замыкания

Функции в Polo++ являются замыканиями - они "запоминают" окружение, в котором были созданы:

```
let makeCounter = lambda (start) {
    let count = start
    lambda () {
        let newCount = (count + int 1)
        let count = newCount
        count
    }
}

let counter = exec makeCounter (int 0)
let one = exec counter ()    // 1
let two = exec counter ()    // 2
```

## Управляющие конструкции

### Условные выражения

Условные выражения имеют следующий синтаксис:

```
if (условие) {
    выражение_если_истина
} else {
    выражение_если_ложь
}
```

Условие должно вычисляться в логическое значение (`bool true` или `bool false`). Оба ветвления должны возвращать значения совместимых типов.

Пример:
```
let max = lambda (a, b) {
    if (a > b) {
        a
    } else {
        b
    }
}
```

## Операторы

### Арифметические операторы

- `+` - сложение (для чисел) или конкатенация (для строк)
- `-` - вычитание
- `*` - умножение
- `/` - деление

Все арифметические операции должны быть заключены в скобки:
```
let result = (a + b)
```

### Операторы сравнения

- `==` - равенство
- `!=` - неравенство
- `<` - меньше
- `>` - больше
- `<=` - меньше или равно
- `>=` - больше или равно

Операторы сравнения возвращают логические значения (`bool true` или `bool false`).

## Работа со списками

Списки в Polo++ представляют собой упорядоченные коллекции элементов, которые могут содержать значения любого типа.

### Создание списков

Списки создаются с помощью квадратных скобок:

```
// Пустой список
let emptyList = []

// Список целых чисел
let numbers = [int 1, int 2, int 3, int 4, int 5]

// Список смешанных типов
let mixed = [int 1, float 2.5, str "hello"]
```

### Операции со списками


#### cons - добавление элемента в начало списка

```
let numbers = [int 1, int 2, int 3]
let newNumbers = exec cons (int 0, numbers)  // Результат: [0, 1, 2, 3]
```

#### head - получение первого элемента списка

```
let numbers = [int 1, int 2, int 3]
let first = exec head (numbers)  // Результат: 1
```

Вызывает ошибку, если список пуст.

#### tail - получение списка без первого элемента

```
let numbers = [int 1, int 2, int 3]
let rest = exec tail (numbers)  // Результат: [2, 3]
```

Если список пуст, возвращает пустой список.

#### isEmpty - проверка на пустоту списка

```
let emptyList = []
let numbers = [int 1, int 2, int 3]
let isEmp1 = exec isEmpty (emptyList)  // Результат: true
let isEmp2 = exec isEmpty (numbers)    // Результат: false
```

#### last - получение последнего элемента списка

```
let numbers = [int 1, int 2, int 3]
let lastElement = exec last (numbers)  // Результат: 3
```

Вызывает ошибку, если список пуст.

#### at - получение элемента по индексу

```
let numbers = [int 1, int 2, int 3, int 4, int 5]
let secondElement = exec at (numbers, int 1)  // Результат: 2
let fourthElement = exec at (numbers, int 3)  // Результат: 4
```

Индексация начинается с 0. Вызывает ошибку, если индекс выходит за границы списка.

#### map - применение функции к каждому элементу списка

```
let numbers = [int 1, int 2, int 3, int 4, int 5]
let double = lambda (x) {
    (x * int 2)
}
let doubled = exec map (double, numbers)  // Результат: [2, 4, 6, 8, 10]
```

### Пример работы со списками

```
// Создание и манипуляция списком
let numbers = [int 1, int 2, int 3, int 4, int 5]
let numbers = exec cons (int 0, numbers)  // [0, 1, 2, 3, 4, 5]
let first = exec head (numbers)           // 0
let rest = exec tail (numbers)            // [1, 2, 3, 4, 5]
let lastElement = exec last (numbers)     // 5
let thirdElement = exec at (numbers, int 2) // 2

// Функциональные преобразования
let square = lambda (x) {
    (x * x)
}
let squares = exec map (square, numbers)  // [0, 1, 4, 9, 16, 25]

// Проверка на пустоту
let emptyList = []
let isEmpty1 = exec isEmpty (emptyList)   // true
let isEmpty2 = exec isEmpty (numbers)     // false
```

## Архитектура интерпретатора

### Синтаксический анализ  

Для построения абстрактного синтаксического дерева (AST) применяется библиотека FParsec, объединяющая лексический и синтаксический анализ в единый процесс. AST представляется рекурсивным типом `Expression`, который охватывает все конструкции языка: примитивные типы (строки, числа, булевы значения), переменные, условные выражения, объявления (включая `let` и `recursive let`), а также функции и их вызовы. Окружение программы реализовано в виде словаря, что обеспечивает поддержку замыканий и рекурсивных функций.  

### Интерпретатор  

Выполнение программы осуществляется с помощью `eval-apply` интерпретатора, рекурсивно обходящего AST и вычисляющего выражения до их окончательных значений. Примитивные значения возвращаются напрямую, переменные разрешаются через поиск в окружении, а условные выражения вычисляют соответствующую ветку в зависимости от результата условия. Объявления (`let` и `recursive let`) расширяют окружение новыми переменными и функциями, включая рекурсивные. Функции создают замыкания, а их вызов (`apply`) подразумевает вычисление аргументов и применение функции к ним. Если структура AST не соответствует ожидаемым шаблонам, интерпретатор сигнализирует об ошибке через исключение.

## Примеры программ

### Пример 1: Вычисление факториала

```
reclet factorial = lambda (n) {
    if (n <= int 1) {
        int 1
    } else {
        (n * exec factorial ((n - int 1)))
    }
}

exec factorial (int 5)  // Результат: Int 120
```

### Пример 2: Числа Фибоначчи

```
reclet fibonacci = lambda (n) {
    if (n <= int 1) {
        int 1
    } else {
        (exec fibonacci ((n - int 1)) + exec fibonacci ((n - int 2)))
    }
}

exec fibonacci (int 7)  // Результат: Int 21
```

### Пример 3: Функции высшего порядка

```
let applyTwice = lambda (f, x) {
    exec f (exec f (x))
}

let double = lambda (x) {
    (x * int 2)
}

exec applyTwice (double, int 3)  // Результат: Int 12 (3 -> 6 -> 12)
```

### Пример 4: Замыкания

```
let makeMultiplier = lambda (factor) {
    lambda (x) {
        (factor * x)
    }
}

let triple = exec makeMultiplier (int 3)
exec triple (int 4)  // Результат: Int 12
```

### Пример 5: Работа со строками

```
let greet = lambda (name) {
    (str "Hello, " + name)
}

exec greet (str "World")  // Результат: String "Hello, World"
```

### Пример 6: Работа со списками

```
// Создание списка
let numbers = [int 1, int 2, int 3, int 4, int 5]

// Манипуляции со списком
let numbers = exec cons (int 0, numbers)
let first = exec head (numbers)
let rest = exec tail (numbers)

// Функциональное преобразование списка
let double = lambda (x) {
    (x * int 2)
}
let doubled = exec map (double, numbers)

// Получение элементов
let lastElement = exec last (numbers)
let thirdElement = exec at (numbers, int 2)

// Результат: [0, 2, 4, 6, 8, 10]
doubled
```
